# ‚öîÔ∏è Sistema de Da√±o Simple - ox_lib Extended

El Sistema de Da√±o Simple proporciona un wrapper b√°sico pero efectivo alrededor de los eventos de da√±o de bajo nivel de FiveM, facilitando la captura, procesamiento y gesti√≥n de eventos de da√±o.

## üìã Caracter√≠sticas Principales

- üéØ **Wrapper simple** de eventos de da√±o nativos
- üìä **Handlers personalizados** para diferentes tipos de da√±o
- üõ°Ô∏è **Sistema de cancelaci√≥n** de da√±o
- üë§ **Tracking espec√≠fico** por jugador y entidad
- üíæ **Informaci√≥n detallada** de da√±o con contexto
- üîß **Utilidades b√°sicas** para gesti√≥n de salud

---

## üöÄ Uso B√°sico

### Instanciaci√≥n

```lua
-- Usar la instancia global (recomendado)
local damage = lib.damage

-- O crear una nueva instancia
local customDamage = lib.class('Damage'):new()
```

### Handlers de Da√±o B√°sicos

```lua
-- Handler general de da√±o
local handlerId = damage:onDamage(function(damageInfo)
    print(string.format("Da√±o detectado: %d a entidad %d por %d",
        damageInfo.damage, damageInfo.entity, damageInfo.attacker))

    -- Retornar false para cancelar el da√±o
    return true -- Permitir da√±o
end)

-- Handler espec√≠fico para jugador
local playerHandlerId = damage:onPlayerDamage(function(damageInfo)
    print(string.format("Jugador recibi√≥ %d de da√±o", damageInfo.damage))

    -- Ejemplo: reducir da√±o si el jugador tiene armadura especial
    if GetPedArmour(damageInfo.entity) > 50 then
        -- Reducir da√±o a la mitad
        damageInfo.damage = damageInfo.damage * 0.5
        return true
    end

    return true
end)

-- Handler para entidad espec√≠fica
local vehicle = GetVehiclePedIsIn(PlayerPedId(), false)
if vehicle ~= 0 then
    local vehicleHandlerId = damage:onEntityDamage(vehicle, function(damageInfo)
        print(string.format("Veh√≠culo %d recibi√≥ %d de da√±o", damageInfo.entity, damageInfo.damage))
        return true
    end)
end
```

---

## üéØ Aplicaci√≥n Manual de Da√±o

### Da√±o B√°sico

```lua
-- Aplicar da√±o a entidad
damage:applyDamage(PlayerPedId(), 50)

-- Aplicar da√±o con arma espec√≠fica
damage:applyDamage(PlayerPedId(), 25, "WEAPON_PISTOL")

-- Aplicar da√±o completo con contexto
damage:applyDamage(PlayerPedId(), 75, "WEAPON_ASSAULTRIFLE", GetPlayerPed(GetPlayerFromServerId(1)), GetEntityCoords(PlayerPedId()))

-- Da√±o a veh√≠culo
local vehicle = GetVehiclePedIsIn(PlayerPedId(), false)
if vehicle ~= 0 then
    damage:applyVehicleDamage(vehicle, 500, 1) -- Da√±o al motor
end
```

---

## üéÆ Ejemplos Pr√°cticos

### Sistema de Da√±o por Zonas

```lua
local ZoneDamage = {}
ZoneDamage.zones = {}

function ZoneDamage:createDamageZone(coords, radius, damagePerSecond, damageType)
    local zoneId = #self.zones + 1

    self.zones[zoneId] = {
        coords = coords,
        radius = radius,
        damagePerSecond = damagePerSecond,
        damageType = damageType or "fire",
        active = true
    }

    return zoneId
end

function ZoneDamage:checkZones()
    local playerPed = PlayerPedId()
    local playerCoords = GetEntityCoords(playerPed)

    for zoneId, zone in pairs(self.zones) do
        if zone.active then
            local distance = #(playerCoords - zone.coords)

            if distance <= zone.radius then
                -- Jugador dentro de zona de da√±o
                local damageAmount = math.max(1, zone.damagePerSecond * (1 - (distance / zone.radius)))

                -- Aplicar da√±o basado en el tipo
                if zone.damageType == "fire" then
                    lib.damage:applyDamage(playerPed, damageAmount, "WEAPON_FIRE")

                    -- Efectos visuales de fuego
                    StartEntityFire(playerPed)

                elseif zone.damageType == "radiation" then
                    lib.damage:applyDamage(playerPed, damageAmount)

                    -- Efectos de radiaci√≥n
                    ShakeGameplayCam("SMALL_EXPLOSION_SHAKE", 0.1)

                elseif zone.damageType == "toxic" then
                    lib.damage:applyDamage(playerPed, damageAmount)

                    -- Efectos t√≥xicos
                    SetPedToRagdoll(playerPed, 1000, 1000, 0, false, false, false)
                end

                print(string.format("Da√±o de zona %s: %.1f", zone.damageType, damageAmount))
            end
        end
    end
end

-- Thread de verificaci√≥n
CreateThread(function()
    while true do
        ZoneDamage:checkZones()
        Wait(1000) -- Verificar cada segundo
    end
end)

-- Crear zonas de ejemplo
ZoneDamage:createDamageZone(vector3(100, 200, 30), 25.0, 5, "fire")      -- Zona de fuego
ZoneDamage:createDamageZone(vector3(200, 300, 25), 50.0, 2, "radiation") -- Zona radioactiva
ZoneDamage:createDamageZone(vector3(300, 400, 20), 15.0, 8, "toxic")     -- Zona t√≥xica
```

### Sistema de Da√±o Personalizado por Arma

```lua
local CustomWeaponDamage = {}
CustomWeaponDamage.weaponMultipliers = {}

function CustomWeaponDamage:init()
    -- Configurar multiplicadores de da√±o por arma
    self.weaponMultipliers = {
        [GetHashKey("WEAPON_PISTOL")] = 0.8,        -- 80% del da√±o base
        [GetHashKey("WEAPON_ASSAULTRIFLE")] = 1.2,  -- 120% del da√±o base
        [GetHashKey("WEAPON_SNIPERRIFLE")] = 2.0,   -- 200% del da√±o base
        [GetHashKey("WEAPON_KNIFE")] = 1.5,         -- 150% del da√±o base
    }

    -- Handler para modificar da√±o de armas
    lib.damage:onDamage(function(damageInfo)
        local weaponHash = damageInfo.weapon
        local multiplier = self.weaponMultipliers[weaponHash]

        if multiplier then
            local originalDamage = damageInfo.damage
            damageInfo.damage = math.floor(damageInfo.damage * multiplier)

            print(string.format("Da√±o modificado: %d -> %d (x%.1f)",
                originalDamage, damageInfo.damage, multiplier))
        end

        return true
    end)
end

function CustomWeaponDamage:setWeaponMultiplier(weaponName, multiplier)
    local weaponHash = GetHashKey(weaponName)
    self.weaponMultipliers[weaponHash] = multiplier
end

-- Inicializar sistema
CustomWeaponDamage:init()

-- Configurar multiplicadores personalizados
CustomWeaponDamage:setWeaponMultiplier("WEAPON_COMBATPISTOL", 0.9)
CustomWeaponDamage:setWeaponMultiplier("WEAPON_PUMPSHOTGUN", 1.8)
```

### Sistema de Protecci√≥n por Trabajo/Rol

```lua
local RoleProtection = {}
RoleProtection.protections = {}

function RoleProtection:init()
    -- Configurar protecciones por trabajo
    self.protections = {
        police = {
            damageReduction = 0.2,  -- 20% menos da√±o
            immuneTo = {"WEAPON_STUNGUN"},
            healingBonus = 1.5
        },
        medic = {
            damageReduction = 0.1,  -- 10% menos da√±o
            immuneTo = {},
            healingBonus = 2.0
        },
        firefighter = {
            damageReduction = 0.15, -- 15% menos da√±o
            immuneTo = {"WEAPON_FIRE", "WEAPON_MOLOTOV"},
            healingBonus = 1.2
        }
    }

    -- Handler de protecci√≥n
    lib.damage:onPlayerDamage(function(damageInfo)
        local playerId = GetPlayerServerId(NetworkGetPlayerIndexFromPed(damageInfo.entity))
        local playerJob = self:getPlayerJob(playerId)

        if playerJob and self.protections[playerJob] then
            local protection = self.protections[playerJob]

            -- Verificar inmunidad
            local weaponName = self:getWeaponNameFromHash(damageInfo.weapon)
            for _, immuneWeapon in ipairs(protection.immuneTo) do
                if weaponName == immuneWeapon then
                    print(string.format("Jugador %d es inmune a %s", playerId, weaponName))
                    return false -- Cancelar da√±o
                end
            end

            -- Aplicar reducci√≥n de da√±o
            if protection.damageReduction > 0 then
                local originalDamage = damageInfo.damage
                damageInfo.damage = math.floor(damageInfo.damage * (1 - protection.damageReduction))

                print(string.format("Da√±o reducido para %s: %d -> %d",
                    playerJob, originalDamage, damageInfo.damage))
            end
        end

        return true
    end)
end

function RoleProtection:getPlayerJob(playerId)
    -- Integraci√≥n con framework (ejemplo)
    if GetResourceState('es_extended') == 'started' then
        local xPlayer = ESX.GetPlayerFromId(playerId)
        return xPlayer and xPlayer.job.name or nil
    elseif GetResourceState('qb-core') == 'started' then
        local Player = QBCore.Functions.GetPlayer(playerId)
        return Player and Player.PlayerData.job.name or nil
    end

    return nil
end

function RoleProtection:getWeaponNameFromHash(weaponHash)
    -- Buscar nombre del arma por hash
    for weaponName, data in pairs(lib.enums.weapons.WEAPONS) do
        if GetHashKey(weaponName) == weaponHash then
            return weaponName
        end
    end
    return "UNKNOWN"
end

-- Inicializar protecciones
RoleProtection:init()
```

### Sistema de Da√±o por Ca√≠da Realista

```lua
local FallDamage = {}
FallDamage.lastHeights = {}

function FallDamage:init()
    -- Handler para da√±o por ca√≠da
    lib.damage:onPlayerDamage(function(damageInfo)
        local playerId = GetPlayerServerId(NetworkGetPlayerIndexFromPed(damageInfo.entity))

        -- Verificar si el da√±o es por ca√≠da
        if damageInfo.weapon == 0 and damageInfo.damage > 0 then
            local ped = damageInfo.entity

            if IsPedFalling(ped) or HasEntityCollidedWithAnything(ped) then
                -- Calcular da√±o realista basado en altura
                local fallHeight = self:calculateFallHeight(playerId, ped)

                if fallHeight > 3.0 then -- Ca√≠da de m√°s de 3 metros
                    local calculatedDamage = self:calculateFallDamage(fallHeight)

                    -- Reemplazar da√±o original con calculado
                    damageInfo.damage = calculatedDamage

                    print(string.format("Ca√≠da de %.1fm: %d de da√±o", fallHeight, calculatedDamage))

                    -- Efectos adicionales para ca√≠das graves
                    if fallHeight > 10.0 then
                        -- Ca√≠da muy alta - efectos adicionales
                        SetPedToRagdoll(ped, 3000, 3000, 0, false, false, false)
                        ShakeGameplayCam("LARGE_EXPLOSION_SHAKE", 0.5)
                    elseif fallHeight > 6.0 then
                        -- Ca√≠da alta - ragdoll temporal
                        SetPedToRagdoll(ped, 1500, 1500, 0, false, false, false)
                    end
                end
            end
        end

        return true
    end)

    -- Thread para trackear alturas
    CreateThread(function()
        while true do
            local ped = PlayerPedId()
            local coords = GetEntityCoords(ped)
            local playerId = GetPlayerServerId(PlayerId())

            if not IsPedInAnyVehicle(ped, false) then
                self.lastHeights[playerId] = coords.z
            end

            Wait(500)
        end
    end)
end

function FallDamage:calculateFallHeight(playerId, ped)
    local currentCoords = GetEntityCoords(ped)
    local lastHeight = self.lastHeights[playerId]

    if lastHeight then
        return math.max(0, lastHeight - currentCoords.z)
    end

    return 0
end

function FallDamage:calculateFallDamage(height)
    -- F√≥rmula realista de da√±o por ca√≠da
    if height < 3.0 then
        return 0
    elseif height < 6.0 then
        return math.floor((height - 3.0) * 15) -- 0-45 da√±o
    elseif height < 15.0 then
        return math.floor(45 + (height - 6.0) * 10) -- 45-135 da√±o
    else
        return 200 -- Ca√≠da mortal
    end
end

-- Inicializar sistema de ca√≠da
FallDamage:init()
```

---

## üîß Utilidades de Salud

### Gesti√≥n B√°sica de Salud

```lua
-- Obtener salud de entidad
local health = damage:getEntityHealth(PlayerPedId())
print("Salud actual:", health)

-- Establecer salud
damage:setEntityHealth(PlayerPedId(), 200)

-- Verificar si est√° muerto
if damage:isEntityDead(PlayerPedId()) then
    print("El jugador est√° muerto")
end

-- Obtener multiplicador de da√±o por parte del cuerpo
local headMultiplier = damage:getDamageMultiplier(lib.enums.damage.BODY_PARTS.HEAD)
print("Multiplicador de cabeza:", headMultiplier) -- 2.0
```

### Sistema de Curaci√≥n Gradual

```lua
local HealingSystem = {}

function HealingSystem:healOverTime(entity, totalAmount, duration, callback)
    local startTime = GetGameTimer()
    local currentHealth = lib.damage:getEntityHealth(entity)
    local maxHealth = GetEntityMaxHealth(entity)
    local targetHealth = math.min(maxHealth, currentHealth + totalAmount)

    CreateThread(function()
        while GetGameTimer() - startTime < duration do
            local progress = (GetGameTimer() - startTime) / duration
            local newHealth = currentHealth + (totalAmount * progress)

            lib.damage:setEntityHealth(entity, math.floor(newHealth))

            Wait(100) -- Actualizar cada 100ms
        end

        lib.damage:setEntityHealth(entity, targetHealth)

        if callback then
            callback()
        end
    end)
end

-- Uso del sistema de curaci√≥n
HealingSystem:healOverTime(PlayerPedId(), 50, 5000, function()
    print("Curaci√≥n completada")
end)
```

---

## üîß Gesti√≥n de Handlers

```lua
-- Remover handler espec√≠fico
damage:removeDamageHandler(handlerId)

-- Ejemplo de handler temporal
local tempHandlerId = damage:onDamage(function(damageInfo)
    print("Handler temporal activado")

    -- Auto-remover despu√©s de 30 segundos
    SetTimeout(30000, function()
        lib.damage:removeDamageHandler(tempHandlerId)
        print("Handler temporal removido")
    end)

    return true
end)
```

---

## üìö Enums Disponibles

### Tipos de Da√±o

```lua
lib.enums.damage.DAMAGE_TYPES.MELEE
lib.enums.damage.DAMAGE_TYPES.BULLET
lib.enums.damage.DAMAGE_TYPES.EXPLOSION
lib.enums.damage.DAMAGE_TYPES.FIRE
lib.enums.damage.DAMAGE_TYPES.COLLISION
lib.enums.damage.DAMAGE_TYPES.FALL
```

### Partes del Cuerpo

```lua
lib.enums.damage.BODY_PARTS.HEAD      -- 31086
lib.enums.damage.BODY_PARTS.NECK      -- 39317
lib.enums.damage.BODY_PARTS.SPINE_1   -- 24816
lib.enums.damage.BODY_PARTS.LEFT_ARM  -- 61163
lib.enums.damage.BODY_PARTS.RIGHT_ARM -- 28252
```

### Multiplicadores de Da√±o

```lua
-- Autom√°ticamente disponibles
local headMultiplier = lib.enums.damage.DAMAGE_MULTIPLIERS[31086] -- 2.0
local neckMultiplier = lib.enums.damage.DAMAGE_MULTIPLIERS[39317] -- 1.5
```

---

## ‚ö†Ô∏è Consideraciones

### Performance

- Los handlers de da√±o se ejecutan frecuentemente en combate
- Evite operaciones costosas dentro de los handlers
- Limite el n√∫mero de handlers activos simult√°neamente

### Limitaciones

- Este es un wrapper simple, no modifica el motor de da√±o nativo
- Algunos tipos de da√±o pueden no ser interceptables
- La cancelaci√≥n de da√±o puede no funcionar en todos los contextos

---

## üîó APIs Relacionadas

- [**Sistema de Armas**](./WEAPONS_API.md) - Para integrar da√±o de armas
- [**Sistema de StateBags**](./STATEBAGS_API.md) - Para sincronizar estados de salud
- [**Sistema de Audio**](./AUDIO_API.md) - Para efectos de audio de da√±o

---

Esta documentaci√≥n cubre el uso b√°sico del Sistema de Da√±o Simple. Para implementaciones m√°s complejas, considera combinar con otros sistemas de ox_lib Extended.
